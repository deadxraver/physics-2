{"ast":null,"code":"var _jsxFileName = \"/Users/sergejpimenov/WebstormProjects/physics-2/src/components/FieldCanvas.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FieldCanvas = ({\n  h1,\n  h2,\n  mu1,\n  mu2,\n  I1,\n  I2,\n  onPointClick\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const scale = 50; // Например, 50 пикселей на 1 метр\n\n  // Определяем положение диэлектрика по Y\n  const dielectricY = 300; // Допустим, на 300 пикселей сверху от начала канваса\n\n  // Положения проводников (в пикселях относительно канваса)\n  // Эти значения будут зависеть от h1, h2 и масштаба\n  // Пусть проводник 1 находится над диэлектриком, проводник 2 под\n  const conductor1X = 200;\n  const conductor1Y = dielectricY - h1 * scale;\n  const conductor2X = 600;\n  const conductor2Y = dielectricY + h2 * scale;\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const drawField = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Рисуем диэлектрик\n      ctx.strokeStyle = 'blue';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(0, dielectricY);\n      ctx.lineTo(canvas.width, dielectricY);\n      ctx.stroke();\n      ctx.fillText(`μ1 (над)`, 10, dielectricY - 10);\n      ctx.fillText(`μ2 (под)`, 10, dielectricY + 20);\n\n      // Рисуем проводники\n      ctx.fillStyle = 'red';\n      ctx.beginPath();\n      ctx.arc(conductor1X, conductor1Y, 5, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillText(`I1: ${I1}A (на нас)`, conductor1X + 10, conductor1Y - 5);\n      ctx.beginPath();\n      ctx.arc(conductor2X, conductor2Y, 5, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillText(`I2: ${I2}A (от нас)`, conductor2X + 10, conductor2Y - 5);\n\n      // Рисуем векторы поля\n      const gridSize = 40; // Размер сетки для векторов\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n      ctx.lineWidth = 1;\n      for (let x = gridSize / 2; x < canvas.width; x += gridSize) {\n        for (let y = gridSize / 2; y < canvas.height; y += gridSize) {\n          // Переводим пиксельные координаты в \"физические\" (относительно проводников)\n          const pointPhysX = (x - conductor1X) / scale; // x-координата относительно проводника 1\n          const pointPhysY = (y - conductor1Y) / scale; // y-координата относительно проводника 1\n\n          // Вычисляем B от проводника 1\n          let B1x = 0;\n          let B1y = 0;\n          const r1 = Math.sqrt((x - conductor1X) ** 2 + (y - conductor1Y) ** 2) / scale;\n          if (r1 > 0.01) {\n            // Избегаем деления на ноль\n            const mu = y < dielectricY ? mu1 : mu2; // Упрощенно: проницаемость среды, где находится точка\n            const B_magnitude1 = mu * I1 / (2 * Math.PI * r1);\n            // Направление: перпендикулярно радиусу. Для тока \"на нас\" (из экрана): (+y, -x)\n            B1x = B_magnitude1 * (y - conductor1Y) / (r1 * scale);\n            B1y = -B_magnitude1 * (x - conductor1X) / (r1 * scale);\n          }\n\n          // Вычисляем B от проводника 2\n          let B2x = 0;\n          let B2y = 0;\n          const r2 = Math.sqrt((x - conductor2X) ** 2 + (y - conductor2Y) ** 2) / scale;\n          if (r2 > 0.01) {\n            const mu = y < dielectricY ? mu1 : mu2; // Упрощенно\n            const B_magnitude2 = mu * I2 / (2 * Math.PI * r2);\n            // Для тока \"от нас\" (в экран): (-y, +x)\n            B2x = -B_magnitude2 * (y - conductor2Y) / (r2 * scale);\n            B2y = B_magnitude2 * (x - conductor2X) / (r2 * scale);\n          }\n\n          // Суммируем векторы\n          const B_totalX = B1x + B2x;\n          const B_totalY = B1y + B2y;\n          const B_total_magnitude = Math.sqrt(B_totalX ** 2 + B_totalY ** 2);\n\n          // Рисуем стрелочку\n          const arrowLength = Math.min(gridSize / 2, B_total_magnitude * 1e5); // Масштабируем для визуализации\n          const angle = Math.atan2(B_totalY, B_totalX);\n          ctx.save();\n          ctx.translate(x, y);\n          ctx.rotate(angle);\n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(arrowLength, 0);\n          ctx.stroke();\n          // Нарисовать наконечник стрелки\n          ctx.beginPath();\n          ctx.moveTo(arrowLength, 0);\n          ctx.lineTo(arrowLength - 5, -3);\n          ctx.moveTo(arrowLength, 0);\n          ctx.lineTo(arrowLength - 5, 3);\n          ctx.stroke();\n          ctx.restore();\n        }\n      }\n    };\n    drawField();\n  }, [h1, h2, mu1, mu2, I1, I2, dielectricY, conductor1X, conductor1Y, conductor2X, conductor2Y]); // Перерисовываем при изменении параметров\n\n  const handleClick = event => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    // Здесь ты будешь вычислять поле в точке mouseX, mouseY\n    // и передавать его в onPointClick\n    const mu = mouseY < dielectricY ? mu1 : mu2;\n    const r1 = Math.sqrt((mouseX - conductor1X) ** 2 + (mouseY - conductor1Y) ** 2) / scale;\n    let B1x = 0,\n      B1y = 0;\n    if (r1 > 0.01) {\n      const B_magnitude1 = mu * I1 / (2 * Math.PI * r1);\n      B1x = B_magnitude1 * (mouseY - conductor1Y) / (r1 * scale);\n      B1y = -B_magnitude1 * (mouseX - conductor1X) / (r1 * scale);\n    }\n    const r2 = Math.sqrt((mouseX - conductor2X) ** 2 + (mouseY - conductor2Y) ** 2) / scale;\n    let B2x = 0,\n      B2y = 0;\n    if (r2 > 0.01) {\n      const B_magnitude2 = mu * I2 / (2 * Math.PI * r2);\n      B2x = -B_magnitude2 * (mouseY - conductor2Y) / (r2 * scale);\n      B2y = B_magnitude2 * (mouseX - conductor2X) / (r2 * scale);\n    }\n    const B_totalX = B1x + B2x;\n    const B_totalY = B1y + B2y;\n    const B_total_magnitude = Math.sqrt(B_totalX ** 2 + B_totalY ** 2);\n    onPointClick({\n      x: mouseX,\n      y: mouseY,\n      B_magnitude: B_total_magnitude,\n      B_x: B_totalX,\n      B_y: B_totalY,\n      mu: mu // Какую проницаемость использовали для расчёта\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: 800,\n    height: 600,\n    style: {\n      border: '1px solid black'\n    },\n    onClick: handleClick\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 157,\n    columnNumber: 9\n  }, this);\n};\n_s(FieldCanvas, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = FieldCanvas;\nexport default FieldCanvas;\nvar _c;\n$RefreshReg$(_c, \"FieldCanvas\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","FieldCanvas","h1","h2","mu1","mu2","I1","I2","onPointClick","_s","canvasRef","scale","dielectricY","conductor1X","conductor1Y","conductor2X","conductor2Y","canvas","current","ctx","getContext","drawField","clearRect","width","height","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","fillText","fillStyle","arc","Math","PI","fill","gridSize","x","y","pointPhysX","pointPhysY","B1x","B1y","r1","sqrt","mu","B_magnitude1","B2x","B2y","r2","B_magnitude2","B_totalX","B_totalY","B_total_magnitude","arrowLength","min","angle","atan2","save","translate","rotate","restore","handleClick","event","rect","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","B_magnitude","B_x","B_y","ref","style","border","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/sergejpimenov/WebstormProjects/physics-2/src/components/FieldCanvas.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\n\nconst FieldCanvas = ({ h1, h2, mu1, mu2, I1, I2, onPointClick }) => {\n    const canvasRef = useRef(null);\n    const scale = 50; // Например, 50 пикселей на 1 метр\n\n    // Определяем положение диэлектрика по Y\n    const dielectricY = 300; // Допустим, на 300 пикселей сверху от начала канваса\n\n    // Положения проводников (в пикселях относительно канваса)\n    // Эти значения будут зависеть от h1, h2 и масштаба\n    // Пусть проводник 1 находится над диэлектриком, проводник 2 под\n    const conductor1X = 200;\n    const conductor1Y = dielectricY - h1 * scale;\n\n    const conductor2X = 600;\n    const conductor2Y = dielectricY + h2 * scale;\n\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n\n        const drawField = () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n            // Рисуем диэлектрик\n            ctx.strokeStyle = 'blue';\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            ctx.moveTo(0, dielectricY);\n            ctx.lineTo(canvas.width, dielectricY);\n            ctx.stroke();\n            ctx.fillText(`μ1 (над)`, 10, dielectricY - 10);\n            ctx.fillText(`μ2 (под)`, 10, dielectricY + 20);\n\n            // Рисуем проводники\n            ctx.fillStyle = 'red';\n            ctx.beginPath();\n            ctx.arc(conductor1X, conductor1Y, 5, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.fillText(`I1: ${I1}A (на нас)`, conductor1X + 10, conductor1Y - 5);\n\n            ctx.beginPath();\n            ctx.arc(conductor2X, conductor2Y, 5, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.fillText(`I2: ${I2}A (от нас)`, conductor2X + 10, conductor2Y - 5);\n\n\n            // Рисуем векторы поля\n            const gridSize = 40; // Размер сетки для векторов\n            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n            ctx.lineWidth = 1;\n\n            for (let x = gridSize / 2; x < canvas.width; x += gridSize) {\n                for (let y = gridSize / 2; y < canvas.height; y += gridSize) {\n                    // Переводим пиксельные координаты в \"физические\" (относительно проводников)\n                    const pointPhysX = (x - conductor1X) / scale; // x-координата относительно проводника 1\n                    const pointPhysY = (y - conductor1Y) / scale; // y-координата относительно проводника 1\n\n                    // Вычисляем B от проводника 1\n                    let B1x = 0;\n                    let B1y = 0;\n                    const r1 = Math.sqrt((x - conductor1X) ** 2 + (y - conductor1Y) ** 2) / scale;\n                    if (r1 > 0.01) { // Избегаем деления на ноль\n                        const mu = y < dielectricY ? mu1 : mu2; // Упрощенно: проницаемость среды, где находится точка\n                        const B_magnitude1 = (mu * I1) / (2 * Math.PI * r1);\n                        // Направление: перпендикулярно радиусу. Для тока \"на нас\" (из экрана): (+y, -x)\n                        B1x = B_magnitude1 * (y - conductor1Y) / (r1 * scale);\n                        B1y = -B_magnitude1 * (x - conductor1X) / (r1 * scale);\n                    }\n\n                    // Вычисляем B от проводника 2\n                    let B2x = 0;\n                    let B2y = 0;\n                    const r2 = Math.sqrt((x - conductor2X) ** 2 + (y - conductor2Y) ** 2) / scale;\n                    if (r2 > 0.01) {\n                        const mu = y < dielectricY ? mu1 : mu2; // Упрощенно\n                        const B_magnitude2 = (mu * I2) / (2 * Math.PI * r2);\n                        // Для тока \"от нас\" (в экран): (-y, +x)\n                        B2x = -B_magnitude2 * (y - conductor2Y) / (r2 * scale);\n                        B2y = B_magnitude2 * (x - conductor2X) / (r2 * scale);\n                    }\n\n                    // Суммируем векторы\n                    const B_totalX = B1x + B2x;\n                    const B_totalY = B1y + B2y;\n                    const B_total_magnitude = Math.sqrt(B_totalX ** 2 + B_totalY ** 2);\n\n                    // Рисуем стрелочку\n                    const arrowLength = Math.min(gridSize / 2, B_total_magnitude * 1e5); // Масштабируем для визуализации\n                    const angle = Math.atan2(B_totalY, B_totalX);\n\n                    ctx.save();\n                    ctx.translate(x, y);\n                    ctx.rotate(angle);\n                    ctx.beginPath();\n                    ctx.moveTo(0, 0);\n                    ctx.lineTo(arrowLength, 0);\n                    ctx.stroke();\n                    // Нарисовать наконечник стрелки\n                    ctx.beginPath();\n                    ctx.moveTo(arrowLength, 0);\n                    ctx.lineTo(arrowLength - 5, -3);\n                    ctx.moveTo(arrowLength, 0);\n                    ctx.lineTo(arrowLength - 5, 3);\n                    ctx.stroke();\n                    ctx.restore();\n                }\n            }\n        };\n\n        drawField();\n    }, [h1, h2, mu1, mu2, I1, I2, dielectricY, conductor1X, conductor1Y, conductor2X, conductor2Y]); // Перерисовываем при изменении параметров\n\n    const handleClick = (event) => {\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n\n        // Здесь ты будешь вычислять поле в точке mouseX, mouseY\n        // и передавать его в onPointClick\n        const mu = mouseY < dielectricY ? mu1 : mu2;\n\n        const r1 = Math.sqrt((mouseX - conductor1X) ** 2 + (mouseY - conductor1Y) ** 2) / scale;\n        let B1x = 0, B1y = 0;\n        if (r1 > 0.01) {\n            const B_magnitude1 = (mu * I1) / (2 * Math.PI * r1);\n            B1x = B_magnitude1 * (mouseY - conductor1Y) / (r1 * scale);\n            B1y = -B_magnitude1 * (mouseX - conductor1X) / (r1 * scale);\n        }\n\n        const r2 = Math.sqrt((mouseX - conductor2X) ** 2 + (mouseY - conductor2Y) ** 2) / scale;\n        let B2x = 0, B2y = 0;\n        if (r2 > 0.01) {\n            const B_magnitude2 = (mu * I2) / (2 * Math.PI * r2);\n            B2x = -B_magnitude2 * (mouseY - conductor2Y) / (r2 * scale);\n            B2y = B_magnitude2 * (mouseX - conductor2X) / (r2 * scale);\n        }\n\n        const B_totalX = B1x + B2x;\n        const B_totalY = B1y + B2y;\n        const B_total_magnitude = Math.sqrt(B_totalX ** 2 + B_totalY ** 2);\n\n        onPointClick({\n            x: mouseX,\n            y: mouseY,\n            B_magnitude: B_total_magnitude,\n            B_x: B_totalX,\n            B_y: B_totalY,\n            mu: mu, // Какую проницаемость использовали для расчёта\n        });\n    };\n\n    return (\n        <canvas\n            ref={canvasRef}\n            width={800}\n            height={600}\n            style={{ border: '1px solid black' }}\n            onClick={handleClick}\n        />\n    );\n};\n\nexport default FieldCanvas;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}